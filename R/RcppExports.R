# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Isotropic exponential covariance function
#'
#' From a matrix of locations and covariance parameters of the form
#' (variance, range, nugget), return the square matrix of
#' all pairwise covariances.
#' @param locs A matrix with \code{n} rows and \code{d} columns.
#' Each row of locs is a point in R^d.
#' @param covparms A vector with covariance parameters
#' in the form (variance, range, nugget)
#' @return A matrix with \code{n} rows and \code{n} columns, with the i,j entry
#' containing the covariance between observations at \code{locs[i,]} and
#' \code{locs[j,]}.
#' @section Parameterization:
#' The covariance parameter vector is (variance, range, nugget)
#' = \eqn{(\sigma^2,\alpha,\tau^2)}, and the covariance function is parameterized
#' as
#' \deqn{ M(x,y) = \sigma^2 exp( - || x - y ||/ \alpha )}
#' The nugget value \eqn{ \sigma^2 \tau^2 } is added to the diagonal of the covariance matrix.
#' NOTE: the nugget is \eqn{ \sigma^2 \tau^2 }, not \eqn{ \tau^2 }. 
exponential_isotropic <- function(covparms, locs) {
    .Call(`_spSGMCMC_exponential_isotropic`, covparms, locs)
}

#' @describeIn exponential_isotropic Derivatives of isotropic exponential covariance
d_exponential_isotropic <- function(covparms, locs) {
    .Call(`_spSGMCMC_d_exponential_isotropic`, covparms, locs)
}

#' Isotropic Matern covariance function
#'
#' From a matrix of locations and covariance parameters of the form
#' (variance, range, smoothness, nugget), return the square matrix of
#' all pairwise covariances.
#' @param locs A matrix with \code{n} rows and \code{d} columns.
#' Each row of locs gives a point in R^d.
#' @param covparms A vector with covariance parameters
#' in the form (variance, range, smoothness, nugget)
#' @return A matrix with \code{n} rows and \code{n} columns, with the i,j entry
#' containing the covariance between observations at \code{locs[i,]} and
#' \code{locs[j,]}.
#' @section Parameterization:
#' The covariance parameter vector is (variance, range, smoothness, nugget)
#' = \eqn{(\sigma^2,\alpha,\nu,\tau^2)}, and the covariance function is parameterized
#' as
#' \deqn{ M(x,y) = \sigma^2 2^{1-\nu}/\Gamma(\nu) (|| x - y ||/\alpha )^\nu K_\nu(|| x - y ||/\alpha ) }
#' The nugget value \eqn{ \sigma^2 \tau^2 } is added to the diagonal of the covariance matrix.
#' NOTE: the nugget is \eqn{ \sigma^2 \tau^2 }, not \eqn{ \tau^2 }. 
matern_isotropic <- function(covparms, locs) {
    .Call(`_spSGMCMC_matern_isotropic`, covparms, locs)
}

#' @describeIn matern_isotropic Derivatives of isotropic Matern covariance
d_matern_isotropic <- function(covparms, locs) {
    .Call(`_spSGMCMC_d_matern_isotropic`, covparms, locs)
}

#' Isotropic Matern covariance function, smoothness = 1.5
#'
#' From a matrix of locations and covariance parameters of the form
#' (variance, range, nugget), return the square matrix of
#' all pairwise covariances.
#' @param locs A matrix with \code{n} rows and \code{d} columns.
#' Each row of locs is a point in R^d.
#' @param covparms A vector with covariance parameters
#' in the form (variance, range, nugget)
#' @return A matrix with \code{n} rows and \code{n} columns, with the i,j entry
#' containing the covariance between observations at \code{locs[i,]} and
#' \code{locs[j,]}.
#' @section Parameterization:
#' The covariance parameter vector is (variance, range, nugget)
#' = \eqn{(\sigma^2,\alpha,\tau^2)}, and the covariance function is parameterized
#' as
#' \deqn{ M(x,y) = \sigma^2 (1 + || x - y || ) exp( - || x - y ||/ \alpha )}
#' The nugget value \eqn{ \sigma^2 \tau^2 } is added to the diagonal of the covariance matrix.
#' NOTE: the nugget is \eqn{ \sigma^2 \tau^2 }, not \eqn{ \tau^2 }. 
matern15_isotropic <- function(covparms, locs) {
    .Call(`_spSGMCMC_matern15_isotropic`, covparms, locs)
}

#' @describeIn exponential_isotropic Derivatives of isotropic 
#' matern covariance with smoothness 1.5
d_matern15_isotropic <- function(covparms, locs) {
    .Call(`_spSGMCMC_d_matern15_isotropic`, covparms, locs)
}

rcpp_matern_isotropic <- function(covparms, locs) {
    .Call(`_spSGMCMC_rcpp_matern_isotropic`, covparms, locs)
}

rcpp_d_matern_isotropic <- function(covparms, locs) {
    .Call(`_spSGMCMC_rcpp_d_matern_isotropic`, covparms, locs)
}

rcpp_matern15_isotropic <- function(covparms, locs) {
    .Call(`_spSGMCMC_rcpp_matern15_isotropic`, covparms, locs)
}

rcpp_d_matern15_isotropic <- function(covparms, locs) {
    .Call(`_spSGMCMC_rcpp_d_matern15_isotropic`, covparms, locs)
}

rcpp_kernel_sexp <- function(M, N, l, s, equal_matrices) {
    .Call(`_spSGMCMC_rcpp_kernel_sexp`, M, N, l, s, equal_matrices)
}

rcpp_d_kernel_sexp_l <- function(M, N, l, s, equal_matrices) {
    .Call(`_spSGMCMC_rcpp_d_kernel_sexp_l`, M, N, l, s, equal_matrices)
}

rcpp_d_kernel_sexp_s <- function(M, N, l, s, equal_matrices) {
    .Call(`_spSGMCMC_rcpp_d_kernel_sexp_s`, M, N, l, s, equal_matrices)
}

#' Multiply approximate inverse Cholesky by a vector
#'
#' Vecchia's approximation implies a sparse approximation to the
#' inverse Cholesky factor of the covariance matrix. This function
#' returns the result of multiplying that matrix by a vector.
#' @param Linv Entries of the sparse inverse Cholesky factor,
#' usually the output from \code{\link{vecchia_Linv}}.
#' @param z the vector to be multiplied
#' @inheritParams vecchia_meanzero_loglik
#' @return the product of the sparse inverse Cholesky factor with a vector
#' @export
Linv_mult <- function(Linv, z, NNarray) {
    .Call(`_spSGMCMC_Linv_mult`, Linv, z, NNarray)
}

#' Multiply approximate Cholesky by a vector
#'
#' Vecchia's approximation implies a sparse approximation to the
#' inverse Cholesky factor of the covariance matrix. This function
#' returns the result of multiplying the inverse of that matrix by a vector
#' (i.e. an approximation to the Cholesky factor).
#' @param Linv Entries of the sparse inverse Cholesky factor,
#' usually the output from \code{\link{vecchia_Linv}}.
#' @param z the vector to be multiplied
#' @inheritParams vecchia_meanzero_loglik
#' @return the product of the Cholesky factor with a vector
#' @export
L_mult <- function(Linv, z, NNarray) {
    .Call(`_spSGMCMC_L_mult`, Linv, z, NNarray)
}

#' Multiply transpose of approximate inverse Cholesky by a vector
#'
#' Vecchia's approximation implies a sparse approximation to the
#' inverse Cholesky factor of the covariance matrix. This function
#' returns the result of multiplying the transpose of that matrix by a vector.
#' @param Linv Entries of the sparse inverse Cholesky factor,
#' usually the output from \code{\link{vecchia_Linv}}.
#' @param z the vector to be multiplied
#' @inheritParams vecchia_meanzero_loglik
#' @return the product of the transpose of the 
#' sparse inverse Cholesky factor with a vector
#' @export
Linv_t_mult <- function(Linv, z, NNarray) {
    .Call(`_spSGMCMC_Linv_t_mult`, Linv, z, NNarray)
}

#' Multiply transpose of approximate Cholesky by a vector
#'
#' Vecchia's approximation implies a sparse approximation to the
#' inverse Cholesky factor of the covariance matrix. This function
#' returns the result of multiplying the transpose of the
#' inverse of that matrix by a vector
#' (i.e. an approximation to the transpose of the Cholesky factor).
#' @param Linv Entries of the sparse inverse Cholesky factor,
#' usually the output from \code{\link{vecchia_Linv}}.
#' @param z the vector to be multiplied
#' @inheritParams vecchia_meanzero_loglik
#' @return the product of the transpose of the Cholesky factor with a vector
#' @export
L_t_mult <- function(Linv, z, NNarray) {
    .Call(`_spSGMCMC_L_t_mult`, Linv, z, NNarray)
}

#' Entries of inverse Cholesky approximation
#'
#' This function returns the entries of the inverse Cholesky
#' factor of the covariance matrix implied by Vecchia's approximation.
#' For return matrix \code{Linv}, \code{Linv[i,]} contains
#' the non-zero entries of row \code{i} of
#' the inverse Cholesky matrix. The columns of the non-zero entries
#' are specified in \code{NNarray[i,]}.
#' @inheritParams vecchia_meanzero_loglik
#' @param start_ind Compute entries of Linv only for rows \code{start_ind}
#' until the last row.
#' @return matrix containing entries of inverse Cholesky
#' @export
vecchia_Linv <- function(covparms, covfun_name, locs, NNarray, start_ind = 1L) {
    .Call(`_spSGMCMC_vecchia_Linv`, covparms, covfun_name, locs, NNarray, start_ind)
}

#' log-prior for regression coefficients \eqn{\beta}
#' We consider a standard normal prior on all the components 
#' @param beta, the current value of the regression parameters
#' @return a scalar i.e the log-prior at beta
#' @export
beta_logpior <- function(beta, var = 1.0) {
    .Call(`_spSGMCMC_beta_logpior`, beta, var)
}

#' gradient of log_prior on \eqn{\beta}
#' @param beta, current value
#' @return vector with same size as \eqn{\beta}
#' @export
beta_grad_logprior <- function(beta, var = 1.0) {
    .Call(`_spSGMCMC_beta_grad_logprior`, beta, var)
}

#' log-prior for matern cov parameters
#' @param covparms \eqn{\sigma^2, \alpha, \nu, \tau^2}
#' the nugget is \eqn{\sigma^2  \tau^2}
#' the priors are log-normal (1,1) for the smoothness \eqn{\nu}
#' Gamma(9,2) for the range \eqn{\alpha}
#' Gamma(.1,.1) for the spatial variance \eqn{\sigma^2}
#' and  Gamma(.1, .1) for the scaled nugget
#' @return a vector of log pdf
#' @export
matern_parms_logprior <- function(covparms, prior_params) {
    .Call(`_spSGMCMC_matern_parms_logprior`, covparms, prior_params)
}

#' gradient of log_prior for matern cov_parameters
#' @param covparms \eqn{\sigma^2, \alpha, \nu, \tau^2}
#' the nugget is \eqn{\sigma^2  \tau^2}
#' the priors are log-normal (1,1) for the smoothness \eqn{\nu}
#' Gamma(9,2) for the range \eqn{\alpha}
#' Gamma(.1,.1) for the spatial variance \eqn{\sigma^2}
#' and  Gamma(.1, .1) for the scaled nugget
#' @return a vector same length as covparms.
#' @export
matern_parms_prior_grad <- function(covparms, prior_params) {
    .Call(`_spSGMCMC_matern_parms_prior_grad`, covparms, prior_params)
}

#' Bijector for the cov parameters
#' all the parameters are sampled on the log scale
#' @export
parms_link <- function(covparms) {
    .Call(`_spSGMCMC_parms_link`, covparms)
}

#' Inverse Bijector for the cov parameters
#' all the parameters are sampled on the log scale
#' @export
parms_invlink <- function(logparms) {
    .Call(`_spSGMCMC_parms_invlink`, logparms)
}

#' Bijector gradient for the cov parameters
#' @export
parms_link_grad <- function(covparms) {
    .Call(`_spSGMCMC_parms_link_grad`, covparms)
}

#' Inverse Bijector gradient for the cov parameters
#' @export
parms_invlink_grad <- function(logparms) {
    .Call(`_spSGMCMC_parms_invlink_grad`, logparms)
}

#' log prior of transformed matern parameters
#' @export
transformed_matern_parms_logprior <- function(logparms, prior_params) {
    .Call(`_spSGMCMC_transformed_matern_parms_logprior`, logparms, prior_params)
}

#' log prior gradient of transformed matern parameters
#' @export
transformed_matern_parms_logprior_grad <- function(logparms, prior_params) {
    .Call(`_spSGMCMC_transformed_matern_parms_logprior_grad`, logparms, prior_params)
}

rcpp_hello_world <- function() {
    .Call(`_spSGMCMC_rcpp_hello_world`)
}

#' @param X Design matrix of covariates. Row \code{i} of \code{X} contains
#' the covariates for the observation at row \code{i} of \code{locs}.
#' @return A list containing
#' \itemize{
#'     \item \code{loglik}: the loglikelihood
#'     \item \code{grad}: gradient with respect to covariance parameters
#'     \item \code{info}: Fisher information for covariance parameters
#'     \item \code{betahat}: profile likelihood estimate of regression coefs
#'     \item \code{betainfo}: information matrix for \code{betahat}.
#'     \item \code{grad_beta}: gradient of the loglikelihood with respect to mean parameters
#' }
#' The covariance matrix for \code{$betahat} is the inverse of \code{$betainfo}.
#' @export
vecchia_profbeta_loglik_grad_info <- function(batch_id, covparms, covfun_name, y, X, current_beta, locs, NNarray) {
    .Call(`_spSGMCMC_vecchia_profbeta_loglik_grad_info`, batch_id, covparms, covfun_name, y, X, current_beta, locs, NNarray)
}

#' Function to transform the gradients and fisher information
#' of the likelihood from the constrained to unconstrained space
#' @param \code{grad} gradient with respect to cov_params
#' @param \code{info} Fisher information for cov_params
#' @param \code{grad_phi} reference to vector for storing unconstrained gradients
#' @param \code{info_phi} reference to matrix for unconstrained Fisher info
#' @export
reparameterized_quantities <- function(cov_params, grad, info, grad_phi, info_phi) {
    invisible(.Call(`_spSGMCMC_reparameterized_quantities`, cov_params, grad, info, grad_phi, info_phi))
}

#' Function to take an SGDRLD step
#' for the covariance parameters
#' This function returns \eqn{( \log(\sigma^2), \log(\alpha), \log(\nu), \log(\tau^2) )_{t+1}}
#' @param \eqn{\epsilon} the step size
#' @param \code{info} the fisher information matrix i.e. preconditionner for the cov parameters
#' @parm \code{cov_params} the current state of the cov parameters
#' @parm \code{grad} sample gradient with respect to \eqn{( \log(\sigma^2), \log(\alpha), \log(\nu), \log(\tau^2) )_{t+1}}
#' @export
SGRLD_step <- function(epsilon, info, cov_params, grad) {
    .Call(`_spSGMCMC_SGRLD_step`, epsilon, info, cov_params, grad)
}

#' Function to run spSGMCMC for a number of iterations
#' @param \code{y}
#' @param \code{X}
#' @param \code{NNarray}
SGRLD_loop <- function(y, X, NNarray, covfun_name, locs, beta_0, covparams0, prior_params, indexes, n_epochs, n_batch, n_burn, lr, thin) {
    .Call(`_spSGMCMC_SGRLD_loop`, y, X, NNarray, covfun_name, locs, beta_0, covparams0, prior_params, indexes, n_epochs, n_batch, n_burn, lr, thin)
}

sample_pieces <- function(batch_id, NNarray, covparms, X, y, locs, covfun_name) {
    .Call(`_spSGMCMC_sample_pieces`, batch_id, NNarray, covparms, X, y, locs, covfun_name)
}

